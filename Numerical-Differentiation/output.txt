Start file: Makefile
CXX = g++
NVCC = nvcc
CXXFLAGS = -Isrc/include -Wall -std=c++17
CUDAFLAGS = -Isrc/include -arch=sm_86  # Update the architecture to match your GPU's capability
LDFLAGS = -lnvToolsExt
TESTFLAGS = -lgtest -lgtest_main -pthread

# Define executables
EXEC = derivative
CUDA_EXEC = derivative_cuda
TOPOLOGY_EXEC = topology
TEST_EXEC = runTests

# Source and CUDA files
SRC_FILES = $(wildcard src/src/*.cpp)
TOPOLOGY_SRC_FILES = src/src/Topology.cpp
CUDA_SRC_FILES = $(wildcard src/src/*.cu)
TEST_SRC_FILES = $(wildcard src/tests/*.cpp)
MAIN_SRC_FILE = src/main.cpp

# Object files
OBJS = $(SRC_FILES:.cpp=.o) $(MAIN_SRC_FILE:.cpp=.o)
TOPOLOGY_OBJS = $(TOPOLOGY_SRC_FILES:.cpp=.o)
CUDA_OBJS = $(CUDA_SRC_FILES:.cu=.o)
TEST_OBJS = $(filter-out $(MAIN_SRC_FILE:.cpp=.o), $(OBJS)) $(TEST_SRC_FILES:.cpp=.o)

# Default target
all: $(CUDA_EXEC) $(TOPOLOGY_EXEC)

# CUDA build target
$(CUDA_EXEC): $(OBJS) $(CUDA_OBJS)
	$(NVCC) $(LDFLAGS) -o $@ $^

# Topology build target
$(TOPOLOGY_EXEC): $(OBJS) $(TOPOLOGY_OBJS) $(CUDA_OBJS)
	$(NVCC) $(LDFLAGS) -o $@ $^ -lcudart

# Build the main executable (only when needed)
build_main: $(EXEC)

$(EXEC): $(OBJS)
	$(CXX) $(LDFLAGS) -o $@ $^

# Build the test executable
build_tests: $(TEST_EXEC)

$(TEST_EXEC): $(TEST_OBJS)
	$(CXX) $(TESTFLAGS) -o $@ $^

# General rule for building object from source
%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

# General rule for building CUDA object from CUDA source
%.o: %.cu
	$(NVCC) $(CUDAFLAGS) -c $< -o $@

# Clean target
clean:
	rm -f $(OBJS) $(TOPOLOGY_OBJS) $(CUDA_OBJS) $(TEST_OBJS) $(EXEC) $(CUDA_EXEC) $(TOPOLOGY_EXEC) $(TEST_EXEC)

.PHONY: all clean build_tests build_main run_tests
End file: Makefile
Start file: main.cpp
#include <iostream>
#include "CudaMathFunctions.h"
#include "nvToolsExt.h"
// #include "MathFunctions.h"
#include "Topology.h"
int main() {


    std::set<int> X = {1, 2, 3};
    std::vector<std::set<int>> openSets = {
        {}, {1}, {1, 2}, {1, 2, 3}
    };
    Topology topology(X, openSets);

    std::set<int> testSet = {1, 2};
    std::cout << "Is {1, 2} an open set? " << (topology.is_open_set(testSet) ? "Yes" : "No") << std::endl;

    // Add any numerical differentiation functionality here if needed


    const int size = 10;
    double xs[size], h = 0.01;
    double sin_values[size], sin_values_plus_h[size], sin_values_minus_h[size];
    double exp_values[size], exp_values_plus_h[size], exp_values_minus_h[size];
    double poly_values[size], poly_values_plus_h[size], poly_values_minus_h[size];
    double derivatives[size];


    for (int i = 0; i < size; i++) {
        xs[i] = 2;  
    }

    forwardCudaSinVector(xs, h, sin_values, sin_values_plus_h, size);
    forwardCudaExponentialVector(xs, h, exp_values, exp_values_plus_h, size);
    forwardCudaPolynomialVector(xs, h, poly_values, poly_values_plus_h, size);

    backwardCudaSinVector(xs, h, sin_values, sin_values_minus_h, size);
    backwardCudaExponentialVector(xs, h, exp_values, exp_values_minus_h, size);
    backwardCudaPolynomialVector(xs, h, poly_values, poly_values_minus_h, size);


    centralCudaSinVector(xs, h, sin_values_minus_h, sin_values_plus_h, size);
    centralCudaExponentialVector(xs, h, exp_values_minus_h, exp_values_plus_h, size);
    centralCudaPolynomialVector(xs, h, poly_values_minus_h, poly_values_plus_h, size);

    for (int i = 0; i < size; i++) {
        double forward_sin_derivative = (sin_values_plus_h[i] - sin_values[i]) / h;
        double forward_exp_derivative = (exp_values_plus_h[i] - exp_values[i]) / h;
        double forward_poly_derivative = (poly_values_plus_h[i] - poly_values[i]) / h;
        std::cout << "Forward x: " << xs[i]
                  << " Sin Derivative: " << forward_sin_derivative
                  << ", Exp Derivative: " << forward_exp_derivative
                  << ", Poly Derivative: " << forward_poly_derivative << std::endl;
    }

    for (int i = 0; i < size; i++) {
        double backward_sin_derivative = (sin_values[i] - sin_values_minus_h[i]) / h;
        double backward_exp_derivative = (exp_values[i] - exp_values_minus_h[i]) / h;
        double backward_poly_derivative = (poly_values[i] - poly_values_minus_h[i]) / h;
        std::cout << "Backward x: " << xs[i]
                  << " Sin Derivative: " << backward_sin_derivative
                  << ", Exp Derivative: " << backward_exp_derivative
                  << ", Poly Derivative: " << backward_poly_derivative << std::endl;
    }

    for (int i = 0; i < size; i++) {
        double central_sin_derivative = (sin_values_plus_h[i] - sin_values_minus_h[i]) / (2 * h);
        double central_exp_derivative = (exp_values_plus_h[i] - exp_values_minus_h[i]) / (2 * h);
        double central_poly_derivative = (poly_values_plus_h[i] - poly_values_minus_h[i]) / (2 * h);
        std::cout << "Central x: " << xs[i]
                  << " Sin Derivative: " << central_sin_derivative
                  << ", Exp Derivative: " << central_exp_derivative
                  << ", Poly Derivative: " << central_poly_derivative << std::endl;
    }

    return 0;
}



End file: main.cpp
Start file: Topology.h
#ifndef TOPOLOGY_H
#define TOPOLOGY_H

#include <vector>
#include <set>

class Topology {
public:
    Topology(const std::set<int>& setX, const std::vector<std::set<int>>& openSets);
    bool is_open_set(const std::set<int>& set) const;

private:
    std::set<int> X;
    std::vector<std::set<int>> T;
};

#endif // TOPOLOGY_H
End file: Topology.h
Start file: CudaMathFunctions.h
#ifndef CUDA_MATH_FUNCTIONS_H
#define CUDA_MATH_FUNCTIONS_H

void forwardCudaSinVector(const double* x, double h, double* f_x, double* f_x_plus_h, int size);
void backwardCudaSinVector(const double* x, double h, double* f_x, double* f_x_minus_h, int size);
void centralCudaSinVector(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size);

void forwardCudaExponentialVector(const double* x, double h, double* f_x, double* f_x_plus_h, int size);
void backwardCudaExponentialVector(const double* x, double h, double* f_x, double* f_x_minus_h, int size);
void centralCudaExponentialVector(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size);

void forwardCudaPolynomialVector(const double* x, double h, double* f_x, double* f_x_plus_h, int size);
void backwardCudaPolynomialVector(const double* x, double h, double* f_x, double* f_x_minus_h, int size);
void centralCudaPolynomialVector(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size);

#endif
End file: CudaMathFunctions.h
Start file: MathFunctions.h
#ifndef MATH_FUNCTIONS_H
#define MATH_FUNCTIONS_H


double polynomial(double x);


double exponential(double x);

#endif
End file: MathFunctions.h
Start file: ForwardDerivative.h
#ifndef FORWARD_DERIVATIVE_H
#define FORWARD_DERIVATIVE_H

double forwardDerivative(double (*func)(double), double x, double h);

#endif
End file: ForwardDerivative.h
Start file: BackwardDerivative.h
#ifndef BACKWARD_DERIVATIVE_H
#define BACKWARD_DERIVATIVE_H

double backwardDerivative(double (*func)(double), double x, double h);

#endif
End file: BackwardDerivative.h
Start file: CentralDerivative.h
#ifndef CENTRAL_DERIVATIVE_H
#define CENTRAL_DERIVATIVE_H

double centralDerivative(double (*func)(double), double x, double h);

#endif
End file: CentralDerivative.h
Start file: Topology.cpp
#include "Topology.h"

Topology::Topology(const std::set<int>& setX, const std::vector<std::set<int>>& openSets) : X(setX), T(openSets) {}

bool Topology::is_open_set(const std::set<int>& set) const {
    for (const auto& openSet : T) {
        if (openSet == set) {
            return true;
        }
    }
    return false;
}
End file: Topology.cpp
Start file: CentralDerivative.cpp
#include "CentralDerivative.h"

double centralDerivative(double (*func)(double), double x, double h) {
    return (func(x + h) - func(x - h)) / (2 * h);
}
End file: CentralDerivative.cpp
Start file: ForwardDerivative.cpp
#include "ForwardDerivative.h"

double forwardDerivative(double (*func)(double), double x, double h) {
    return (func(x + h) - func(x)) / h;
}
End file: ForwardDerivative.cpp
Start file: CudaMathfunctions.cu
#include "CudaMathFunctions.h"
#include <cmath>
#include <cuda_runtime.h>
#include "nvToolsExt.h"
// Sine Kernels
__global__ void forwardSinKernel(const double* x, double h, double* f_x, double* f_x_plus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        f_x[idx] = sin(x[idx]);
        f_x_plus_h[idx] = sin(x[idx] + h);
    }
}

__global__ void backwardSinKernel(const double* x, double h, double* f_x, double* f_x_minus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        f_x[idx] = sin(x[idx]);
        f_x_minus_h[idx] = sin(x[idx] - h);
    }
}

__global__ void centralSinKernel(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        f_x_minus_h[idx] = sin(x[idx] - h);
        f_x_plus_h[idx] = sin(x[idx] + h);
    }
}

// Exponential Kernels
__global__ void forwardExponentialKernel(const double* x, double h, double* f_x, double* f_x_plus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        f_x[idx] = exp(x[idx]);
        f_x_plus_h[idx] = exp(x[idx] + h);
    }
}

__global__ void backwardExponentialKernel(const double* x, double h, double* f_x, double* f_x_minus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        f_x[idx] = exp(x[idx]);
        f_x_minus_h[idx] = exp(x[idx] - h);
    }
}

__global__ void centralExponentialKernel(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        f_x_minus_h[idx] = exp(x[idx] - h);
        f_x_plus_h[idx] = exp(x[idx] + h);
    }
}

// Polynomial Kernels
__global__ void forwardPolynomialKernel(const double* x, double h, double* f_x, double* f_x_plus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        double x_val = x[idx];
        f_x[idx] = x_val * x_val - 4 * x_val + 4;
        f_x_plus_h[idx] = (x_val + h) * (x_val + h) - 4 * (x_val + h) + 4;
    }
}

__global__ void backwardPolynomialKernel(const double* x, double h, double* f_x, double* f_x_minus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        double x_val = x[idx];
        f_x[idx] = x_val * x_val - 4 * x_val + 4;
        f_x_minus_h[idx] = (x_val - h) * (x_val - h) - 4 * (x_val - h) + 4;
    }
}

__global__ void centralPolynomialKernel(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < size) {
        double x_val = x[idx] - h;
        f_x_minus_h[idx] = x_val * x_val - 4 * x_val + 4;
        x_val = x[idx] + h;
        f_x_plus_h[idx] = x_val * x_val - 4 * x_val + 4;
    }
}



void forwardCudaSinVector(const double* x, double h, double* f_x, double* f_x_plus_h, int size) {
    double *d_x, *d_f_x, *d_f_x_plus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x, size * sizeof(double));
    cudaMalloc(&d_f_x_plus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Forward Sine Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    forwardSinKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x, d_f_x_plus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x, d_f_x, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_plus_h, d_f_x_plus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x);
    cudaFree(d_f_x_plus_h);
}

void backwardCudaSinVector(const double* x, double h, double* f_x, double* f_x_minus_h, int size) {
    double *d_x, *d_f_x, *d_f_x_minus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x, size * sizeof(double));
    cudaMalloc(&d_f_x_minus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Backward Sine Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    backwardSinKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x, d_f_x_minus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x, d_f_x, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_minus_h, d_f_x_minus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x);
    cudaFree(d_f_x_minus_h);
}

void centralCudaSinVector(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size) {
    double *d_x, *d_f_x_minus_h, *d_f_x_plus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x_minus_h, size * sizeof(double));
    cudaMalloc(&d_f_x_plus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Central Sine Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    centralSinKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x_minus_h, d_f_x_plus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x_minus_h, d_f_x_minus_h, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_plus_h, d_f_x_plus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x_minus_h);
    cudaFree(d_f_x_plus_h);
}


void backwardCudaExponentialVector(const double* x, double h, double* f_x, double* f_x_minus_h, int size) {
    double *d_x, *d_f_x, *d_f_x_minus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x, size * sizeof(double));
    cudaMalloc(&d_f_x_minus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Backward Exponential Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    backwardExponentialKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x, d_f_x_minus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x, d_f_x, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_minus_h, d_f_x_minus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x);
    cudaFree(d_f_x_minus_h);
}


void centralCudaExponentialVector(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size) {
    double *d_x, *d_f_x_minus_h, *d_f_x_plus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x_minus_h, size * sizeof(double));
    cudaMalloc(&d_f_x_plus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Central Exponential Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    centralExponentialKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x_minus_h, d_f_x_plus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x_minus_h, d_f_x_minus_h, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_plus_h, d_f_x_plus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x_minus_h);
    cudaFree(d_f_x_plus_h);
}

void backwardCudaPolynomialVector(const double* x, double h, double* f_x, double* f_x_minus_h, int size) {
    double *d_x, *d_f_x, *d_f_x_minus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x, size * sizeof(double));
    cudaMalloc(&d_f_x_minus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Backward Polynomial Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    backwardPolynomialKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x, d_f_x_minus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x, d_f_x, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_minus_h, d_f_x_minus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x);
    cudaFree(d_f_x_minus_h);
}


void centralCudaPolynomialVector(const double* x, double h, double* f_x_minus_h, double* f_x_plus_h, int size) {
    double *d_x, *d_f_x_minus_h, *d_f_x_plus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x_minus_h, size * sizeof(double));
    cudaMalloc(&d_f_x_plus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Central Polynomial Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    centralPolynomialKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x_minus_h, d_f_x_plus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x_minus_h, d_f_x_minus_h, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_plus_h, d_f_x_plus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x_minus_h);
    cudaFree(d_f_x_plus_h);
}


void forwardCudaPolynomialVector(const double* x, double h, double* f_x, double* f_x_plus_h, int size) {
    double *d_x, *d_f_x, *d_f_x_plus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x, size * sizeof(double));
    cudaMalloc(&d_f_x_plus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Forward Polynomial Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    forwardPolynomialKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x, d_f_x_plus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x, d_f_x, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_plus_h, d_f_x_plus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x);
    cudaFree(d_f_x_plus_h);
}


void forwardCudaExponentialVector(const double* x, double h, double* f_x, double* f_x_plus_h, int size) {
    double *d_x, *d_f_x, *d_f_x_plus_h;
    cudaMalloc(&d_x, size * sizeof(double));
    cudaMalloc(&d_f_x, size * sizeof(double));
    cudaMalloc(&d_f_x_plus_h, size * sizeof(double));

    cudaMemcpy(d_x, x, size * sizeof(double), cudaMemcpyHostToDevice);

    nvtxRangePush("Forward Exponential Kernel Launch");
    int blockSize = 256;
    int numBlocks = (size + blockSize - 1) / blockSize;
    forwardExponentialKernel<<<numBlocks, blockSize>>>(d_x, h, d_f_x, d_f_x_plus_h, size);
    cudaDeviceSynchronize();
    nvtxRangePop();

    cudaMemcpy(f_x, d_f_x, size * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_x_plus_h, d_f_x_plus_h, size * sizeof(double), cudaMemcpyDeviceToHost);

    cudaFree(d_x);
    cudaFree(d_f_x);
    cudaFree(d_f_x_plus_h);
}

End file: CudaMathfunctions.cu
Start file: MathFunctions.cpp
#include "MathFunctions.h"
#include <cmath> 


double polynomial(double x) {
    return x*x - 4*x + 4;  // Example polynomial: x^2 - 4x + 4
}


double exponential(double x) {
    return exp(x);
}
End file: MathFunctions.cpp
Start file: BackwardDerivative.cpp
#include "BackwardDerivative.h"

double backwardDerivative(double (*func)(double), double x, double h) {
    return (func(x) - func(x - h)) / h;
}
End file: BackwardDerivative.cpp
Start file: MathFunctionsTest.cpp

End file: MathFunctionsTest.cpp
